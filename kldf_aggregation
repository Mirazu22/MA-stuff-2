import pandas as pd
import numpy as np
from typing import Dict, Tuple

__all__ = [
    "parent",
    "build_map",
    "aggregate_employment",
    "aggregate_matrix",
    "aggregate_kldb",
    "summarise_aggregation",
    "row_stochastic",
]

# ---------------------------------------------------------------------------
# 1. helpers
# ---------------------------------------------------------------------------

def parent(code: str | int, digits: int = 3) -> str:
    """Return the *prefix* of a KldB-4 code.

    Works with both integer and string codes.

    Examples
    --------
    >>> parent(1234, 3)
    '123'
    >>> parent('1234', 2)
    '12'
    """
    if digits not in (2, 3):
        raise ValueError("digits must be 2 or 3 for KldB aggregation")
    code_str = str(code)
    if len(code_str) < digits:
        raise ValueError(
            f"code '{code_str}' shorter than requested prefix length {digits}"
        )
    return code_str[:digits]


def _to_str_index(obj: pd.Series | pd.DataFrame):
    """Return a *copy* with the index (and columns if DataFrame) coerced to str."""
    out = obj.copy()
    out.index = out.index.astype(str)
    if isinstance(out, pd.DataFrame):
        out.columns = out.columns.astype(str)
    return out

# ---------------------------------------------------------------------------
# 2. build the aggregation map
# ---------------------------------------------------------------------------

def build_map(empl: pd.Series, *, threshold: int) -> Dict[str, str]:
    """Create a mapping from every 4‑digit code to its aggregated bucket.

    Step 1 – collapse to 3‑digit parents.  Step 2 – if the 3‑digit bucket is
    still below *threshold*, collapse further to 2‑digit.
    """
    empl_str = _to_str_index(empl)

    codes = empl_str.index
    map3 = codes.to_series().map(lambda c: parent(c, 3))
    mapping: Dict[str, str] = dict(zip(codes, map3))

    # Totals on the 3‑digit level
    empl3 = empl_str.groupby(map3).sum()

    low3 = empl3[empl3 < threshold].index
    if not low3.empty:
        for code in codes:
            if mapping[code] in low3:
                mapping[code] = parent(code, 2)

    return mapping

# ---------------------------------------------------------------------------
# 3. aggregation helpers
# ---------------------------------------------------------------------------

def aggregate_employment(empl: pd.Series, mapping: Dict[str, str]) -> pd.Series:
    """Aggregate an employment vector using *mapping* (handles int indices)."""
    empl_str = _to_str_index(empl)
    grouped = empl_str.groupby(empl_str.index.map(mapping)).sum()
    return grouped.sort_index()


def aggregate_matrix(trans: pd.DataFrame, mapping: Dict[str, str]) -> pd.DataFrame:
    """Aggregate both rows and columns of a transition count matrix.

    Accepts DataFrames whose indices/columns are int64 or str.
    """
    trans_str = _to_str_index(trans)

    # Group rows then columns
    rows = trans_str.groupby(mapping, axis=0).sum()
    cols = rows.groupby(mapping, axis=1).sum()
    keys = sorted(cols.index)
    return cols.loc[keys, keys]

# ---------------------------------------------------------------------------
# 4. summarisation helper
# ---------------------------------------------------------------------------

def summarise_aggregation(mapping: Dict[str, str], empl: pd.Series) -> pd.DataFrame:
    """DataFrame with one row per final bucket and aggregation details."""
    empl_str = _to_str_index(empl)  # ensure index comparable to mapping keys
    df = pd.DataFrame({
        "origin": list(mapping.keys()),
        "agg": [mapping[k] for k in mapping.keys()],
    })
    df["empl"] = df["origin"].map(empl_str)
    summary = (
        df.groupby("agg")
        .agg(
            members=("origin", list),
            total_employment=("empl", "sum"),
        )
        .assign(num_codes=lambda d: d["members"].str.len())
        .sort_index()
    )
    return summary

# ---------------------------------------------------------------------------
# 5. high‑level convenience wrapper
# ---------------------------------------------------------------------------

def aggregate_kldb(
    trans: pd.DataFrame,
    empl: pd.Series,
    *,
    threshold: int = 5_000,
    warn_if_unresolved: bool = True,
) -> Tuple[pd.DataFrame, pd.Series, Dict[str, str], pd.DataFrame]:
    """Collapse KldB‑4 transition counts until employment ≥ *threshold*."""
    mapping = build_map(empl, threshold=threshold)
    empl_new = aggregate_employment(empl, mapping)
    trans_new = aggregate_matrix(trans, mapping)
    summary = summarise_aggregation(mapping, empl)

    if warn_if_unresolved and (empl_new < threshold).any():
        import warnings
        warnings.warn(
            "Some buckets remain below the threshold even after 2‑digit aggregation.",
            RuntimeWarning,
        )

    return trans_new, empl_new, mapping, summary

# ---------------------------------------------------------------------------
# 6. optional: convert counts to row‑stochastic probabilities
# ---------------------------------------------------------------------------

def row_stochastic(counts: pd.DataFrame) -> pd.DataFrame:
    """Normalise each row of *counts* so it sums to 1 (zero rows ignored)."""
    totals = counts.sum(axis=1).replace(0, np.nan)
    return counts.div(totals, axis=0)

# ---------------------------------------------------------------------------
# 7. minimal self‑test
# ---------------------------------------------------------------------------

if __name__ == "__main__":
    # Toy data with *integer* indices to mimic the user's case
    idx_int = [1234, 1235, 1241, 2111, 2112, 3110]
    np.random.seed(1)
    toy_trans_int = pd.DataFrame(
        np.random.randint(0, 100, size=(len(idx_int), len(idx_int))),
        index=idx_int,
        columns=idx_int,
    )
    toy_empl_int = pd.Series([200, 150, 50, 90, 40, 10], index=idx_int)

    T, E, M, S = aggregate_kldb(toy_trans_int, toy_empl_int, threshold=200)
    print("Aggregated employment:\n", E)
    print("\nAggregated transition matrix:\n", T)
    print("\nMapping:\n", M)
    print("\nSummary:\n", S)
