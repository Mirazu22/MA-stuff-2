import numpy as np
from scipy import sparse

def tfidf_cosine_similarity_scipy(X_csr: sparse.csr_matrix, smooth_idf: bool = True) -> sparse.csr_matrix:
    """
    TFâ€“IDF + cosine similarity using only NumPy + SciPy.
    X is occupation x task (can be weighted).

    Steps:
      df_w = #occ where task w present
      idf_w = log((N+1)/(df_w+1)) + 1   (if smooth_idf) else log(N/df_w)
      Z = X * idf  (column scaling)
      Z_norm = row-wise L2 normalization
      S = Z_norm @ Z_norm^T

    Returns sparse CSR matrix S.
    """
    X = X_csr.tocsr().astype(float)
    n_occ = X.shape[0]

    # document frequency based on presence (not magnitude)
    A = (X > 0).astype(np.int8)
    df = np.asarray(A.sum(axis=0)).ravel().astype(float)

    if smooth_idf:
        idf = np.log((n_occ + 1.0) / (df + 1.0)) + 1.0
    else:
        df[df == 0] = np.nan
        idf = np.log(n_occ / df)

    # TF-IDF via column scaling
    Z = X.multiply(idf)

    # Row-wise L2 normalization: Z_norm = D^{-1} Z, where D_i = ||Z_i||_2
    row_sq_sum = np.asarray(Z.multiply(Z).sum(axis=1)).ravel()
    row_norm = np.sqrt(row_sq_sum)
    row_norm[row_norm == 0.0] = 1.0  # avoid division by zero for empty rows
    inv_row_norm = 1.0 / row_norm

    # Left-multiply by diagonal matrix of inv norms (efficient)
    Z_norm = sparse.diags(inv_row_norm) @ Z

    # Cosine similarity
    S = Z_norm @ Z_norm.T
    S.setdiag(0.0)
    S.eliminate_zeros()
    return S